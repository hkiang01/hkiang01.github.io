[{"uri":"https://hkiang01.github.io/philosophy/","title":"Philosophy","tags":[],"description":"","content":"This looks much better in mobile vs desktop.\nChapter 1 Philosophy A few things I believe are true\n  If you automate common tasks you perform, you become your own force multiplier (see Eliminating Toil in the Google SRE book).\n  A feature doesn\u0026rsquo;t exist unless there\u0026rsquo;s a test for it, because manually testing over and over again is just not worth it\n  Tests should only be written against well-known standards, e.g., REST APIs, and avoid being tightly bound to implementation if possible\n  As long as your code has a deadline, it will never be \u0026ldquo;perfect\u0026rdquo; (limited time budget).\n  Even if your code doesn\u0026rsquo;t have a deadline, it will never be \u0026ldquo;perfect\u0026rdquo; (limited incentive).\n  Companies will never over-provision human resources, just like they will never over-provision cloud resources (or at least shouldn\u0026rsquo;t).\n  \u0026ldquo;Agile\u0026rdquo; means something different to everyone, so the term itself doesn\u0026rsquo;t really mean anything. Everyone has an opinion, especially Deloitte.\n  Working near a waterfall is peaceful, but you\u0026rsquo;ll surely get wet while working under one.\n  If you can pass \u0026lt;insert regulation\u0026gt; audits and still get your job done, you\u0026rsquo;re winning, especially if you can also squeeze in ad-hoc work items during your sprint in a \u0026lt;insert regulation\u0026gt; compliant fashion.\n  Story estimations are only necessary to those who lack or who have never have had an understanding of the code base(s) they work with, or within large, centrally-planned companies where that is often the case (the planning committee can only have so much understanding).\n  The planning committee rightfully deserves accurate and timely information to do their job, they\u0026rsquo;re human too.\n  Multiple sources of truth muddy the waters. A potential solution: a singular planning committee.\n  There is a right balance w.r.t. the number of planning hours vs non-planning hours, error on the side of too many non-planning hours.\n  A \u0026ldquo;Best Practice\u0026rdquo; often refers to the best way the team lead knows how to do something at that point in time. \u0026ldquo;Best Practices\u0026rdquo; should change when the team is aware of a demonstrated better way of doing something.\n  \u0026ldquo;Best Practices\u0026rdquo; should then be documented for posterity.\n  Always be learning\n  Posture! Your lower back should be flush with your chair.\n  "},{"uri":"https://hkiang01.github.io/kubernetes/keycloak/","title":"Keycloak","tags":[],"description":"","content":"Keycloak is an identity management solution useful for securing applications in Kubernetes. This post shows how to set up Keycloak and secure an application in Kubernetes with Keycloak. Sample code available at https://github.com/hkiang01/keycloak-demo.\n Installing Keycloak  Simple first Database for production readiness  Creating the chart Adding Postgres     Preparing Keycloak  Create a Realm Create a Client Create a User Testing out your User   Securing your application  Setting up the gatekeeper sidecar Deploy secured app Fixing the audience   Some understanding Next steps  Installing Keycloak Simple first We\u0026rsquo;re going to see what it takes to minimally get Keycloak to run in Kubernetes. First, we\u0026rsquo;ll create a namespace called keycloak\nkubectl create namespace keycloak We\u0026rsquo;ll then get the quickstart manifest from https://github.com/keycloak/keycloak-quickstarts/tree/latest/kubernetes-examples. I\u0026rsquo;ve made a few edits, namely:\n Service type changed to ClusterIP namespaces changed to \u0026ldquo;keycloak\u0026rdquo;  I\u0026rsquo;ll call mine keycloak.yaml\n# keycloak.yaml apiVersion: v1 kind: Service metadata: name: keycloak namespace: keycloak labels: app: keycloak spec: ports: - name: http port: 8080 targetPort: 8080 selector: app: keycloak type: ClusterIP --- apiVersion: apps/v1 kind: Deployment metadata: name: keycloak namespace: keycloak labels: app: keycloak spec: replicas: 1 selector: matchLabels: app: keycloak template: metadata: labels: app: keycloak spec: containers: - name: keycloak image: quay.io/keycloak/keycloak:11.0.2 env: - name: KEYCLOAK_USER value: \u0026#34;admin\u0026#34; - name: KEYCLOAK_PASSWORD value: \u0026#34;admin\u0026#34; - name: PROXY_ADDRESS_FORWARDING value: \u0026#34;true\u0026#34; ports: - name: http containerPort: 8080 - name: https containerPort: 8443 readinessProbe: httpGet: path: /auth/realms/master port: 8080 Let\u0026rsquo;s apply it\nkubectl apply -f keycloak.yaml Let\u0026rsquo;s make sure it\u0026rsquo;s up and running:\nkubectl get all -n keycloak You should see that the pods are all ready. Below, 1 of 1 pods are ready, as indicated by 1/1.\nNAME READY STATUS RESTARTS AGE pod/keycloak-6bc5f6d94c-bdbln 1/1 Running 0 3m25s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/keycloak ClusterIP 10.152.183.91 \u0026lt;none\u0026gt; 8080/TCP 3m26s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/keycloak 1/1 1 1 3m25s NAME DESIRED CURRENT READY AGE replicaset.apps/keycloak-6bc5f6d94c 1 1 1 3m25s To access the app, we\u0026rsquo;ll need to port-forward the service:\nkubectl -n keycloak port-forward svc/keycloak 8080 You should see output like the following:\nForwarding from 127.0.0.1:8080 -\u0026gt; 8080 Forwarding from [::1]:8080 -\u0026gt; 8080 We should now be able to access the instance at http://localhost:8080 in our browser. Before we continue, let\u0026rsquo;s do some cleanup:\nkubectl delete -f keycloak.yaml Database for production readiness Creating the chart Keycloak is a stateful application that is backed by a database like Postgres. We\u0026rsquo;re going to take the above manifest from Installing Keycloak and paste it as a template in a new Helm chart with Postgres as a package dependency. You can use an existing chart, but I think it\u0026rsquo;s valuable to see what a minimal chart looks like.\nLet\u0026rsquo;s first create a chart called keycloak:\nhelm create keycloak This is the file tree of what\u0026rsquo;s created\n├── keycloak │ ├── charts │ ├── Chart.yaml │ ├── templates │ │ ├── deployment.yaml │ │ ├── _helpers.tpl │ │ ├── hpa.yaml │ │ ├── ingress.yaml │ │ ├── NOTES.txt │ │ ├── serviceaccount.yaml │ │ ├── service.yaml │ │ └── tests │ │ └── test-connection.yaml │ └── values.yaml We can get rid of the following in templates/:\n hpa.yaml tests/  cd keycloak/templates/ rm -rf hpa.yaml tests/ Let\u0026rsquo;s configure the chart to use the keycloak image. We can accomplish this with the follwing in values.yaml at the root of the chart.\n# keycloak/values.yaml image: repository: quay.io/keycloak/keycloak pullPolicy: IfNotPresent # Overrides the image tag whose default is the chart appVersion. tag: \u0026#34;11.0.2\u0026#34; And configure our credentials:\nYou should never store secrets in plaintext in your repo history. The snippet below is for demonstration purposes only.\n # keycloak/values.yaml username: admin password: supersecretpassword  You can use Sealed Secrets for Kubernetes and store secrets in encrypted form in your chart\u0026rsquo;s templates. See Usage to get started.\n The container environment variables, ports, and probes will have to be copied over as well.\n# keycloak/templates/deployment.yaml containers: - name: {{ .Chart.Name }} securityContext: {{- toYaml .Values.securityContext | nindent 12 }} image: \u0026#34;{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}\u0026#34; imagePullPolicy: {{ .Values.image.pullPolicy }} env: - name: KEYCLOAK_USER value: {{ .Values.username }} - name: KEYCLOAK_PASSWORD value: {{ .Values.password }} - name: PROXY_ADDRESS_FORWARDING value: \u0026#34;true\u0026#34; ports: - name: http containerPort: 8080 protocol: TCP - name: https containerPort: 8443 livenessProbe: httpGet: path: / port: http readinessProbe: httpGet: path: /auth/realms/master port: http We can now test our chart to make sure we have the same level of access as before. Perform the following command in a directory containing the keycloak/ directory that is the chart we created:\nhelm -n keycloak upgrade --install keycloak ./keycloak Port-forward the service:\nkubectl -n keycloak port-forward svc/keycloak 8080:80 We should now be able to access the instance at http://localhost:8080 in our browser.\nAdding Postgres The reason we want to add Postgresql via a Helm dependency is that a lot of the legwork with respect to ensuring availability and persistence is already done for you. There are packages that offer high availability, but here we\u0026rsquo;ll just go for the standard postgresql package.\nLet\u0026rsquo;s add the dependency:\n# keycloak/Chart.yaml dependencies: - name: postgresql version: 9.8.6 repository: https://charts.bitnami.com/bitnami Pull the dependency:\nhelm dependency update ./keycloak You should see output like below:\n...Successfully got an update from the \u0026#34;bitnami\u0026#34; chart repository Update Complete. ⎈Happy Helming!⎈ Saving 1 charts Downloading postgresql from repo https://charts.bitnami.com/bitnami Deleting outdated charts You can now observe the chart itself. We\u0026rsquo;re going to configure it by continuing to edit the same values.yaml file we used to set the chart\u0026rsquo;s image to keycloak to configure out secrets\nYou should never store secrets in plaintext in your repo history. The snippet below is for demonstration purposes only.\n # keycloak/values.yaml postgresql: postgresqlUsername: postgres postgresqlPassword: secretpassword postgresqlDatabase: keycloak service: port: 5432  Use a Kubernetes Secret to define your credentials and point postgresql.existingSecret in values.yaml to it. You can use Sealed Secrets for Kubernetes and store secrets in encrypted form in your chart\u0026rsquo;s templates. See Usage to get started.\n Now we have to make Keycloak talk to Postgres.\n# keycloak/templates/deployment.yaml env: - name: KEYCLOAK_USER value: {{ .Values.username }} - name: KEYCLOAK_PASSWORD value: {{ .Values.password }} - name: PROXY_ADDRESS_FORWARDING value: \u0026#34;true\u0026#34; - name: DB_VENDOR value: postgres - name: DB_ADDR value: {{ include \u0026#34;keycloak.fullname\u0026#34; . }}-postgresql - name: DB_PORT value: {{ .Values.postgresql.service.port | quote }} - name: DB_DATABASE value: {{ .Values.postgresql.postgresqlDatabase }} - name: DB_USER value: {{ .Values.postgresql.postgresqlUsername }} - name: DB_PASSWORD value: {{ .Values.postgresql.postgresqlPassword }} Deploy the chart:\nhelm -n keycloak upgrade --install keycloak ./keycloak You should see output like the following:\nRelease \u0026#34;keycloak\u0026#34; has been upgraded. Happy Helming! NAME: keycloak LAST DEPLOYED: Sun Oct 25 01:02:10 2020 NAMESPACE: keycloak STATUS: deployed REVISION: 5 TEST SUITE: None NOTES: 1. Get the application URL by running these commands: export POD_NAME=$(kubectl get pods --namespace keycloak -l \u0026#34;app.kubernetes.io/name=keycloak,app.kubernetes.io/instance=keycloak\u0026#34; -o jsonpath=\u0026#34;{.items[0].metadata.name}\u0026#34;) echo \u0026#34;Visit http://127.0.0.1:8080 to use your application\u0026#34; kubectl --namespace keycloak port-forward $POD_NAME 8080:80 By following the instructions from the output above, you should be able to access an instance of keycloak backed by Postgres.\nTo validate that your instance is backed by Postgres, you can tail the logs of the Keycloak pod:\nkubectl -n keycloak logs -f -l=app.kubernetes.io/name=keycloak You should see output like below:\n========================================================================= Using PostgreSQL database ========================================================================= ... Preparing Keycloak Create a Realm Keycloak has Realms:\n Keycloak supports multiple tenancy where all users, clients, and so on are grouped in what is called a realm. Each realm is independent of other realms.\n- Securing Applications and Services Guide\n By default, Keycloak sets up a \u0026ldquo;Master\u0026rdquo; Realm that can only be used to create other Realms. Let\u0026rsquo;s create a Realm and call it \u0026ldquo;demo\u0026rdquo; by following the instructions outlined in Creating a realm. Once the Realm is created you should see something like this:\nCreate a Client  In order for an application or service to utilize Keycloak it has to register a client in Keycloak.\n- Client Registration\n We\u0026rsquo;ll have to create an OIDC client. Let\u0026rsquo;s do so by following the instructions outlined in OIDC Clients. It\u0026rsquo;s a good idea to enter a \u0026ldquo;Root URL\u0026rdquo; as the resultant Client Settings page will fill out all the nuanced fields for you.\nIn Client Settings, scroll down and ensure \u0026ldquo;Direct Access Grants Enabled\u0026rdquo; is toggled to \u0026ldquo;On\u0026rdquo; and change the \u0026ldquo;Access Type\u0026rdquo; to confidential, then click \u0026ldquo;Save\u0026rdquo;. You should now see a \u0026ldquo;Credentials\u0026rdquo; tab appear in the client like below (see Confidential Client Credentials):\nNote the value in \u0026ldquo;Secret\u0026rdquo;, we\u0026rsquo;re going to use that when performing our password grant.\nCreate a User Next, create a user by following the instructions outlined in Creating a user.\nThen give the user a password by filling out the form under the \u0026ldquo;Credentials\u0026rdquo; tab for the user.\nFor demonstration purposes, I\u0026rsquo;m opting to flip the \u0026ldquo;Temporary\u0026rdquo; switch to \u0026ldquo;Off\u0026rdquo;.\nYou should then be able to log in by following the instructions outlined in Logging into the account console. You should see something like this:\nVerify that your user has access to your application by observing your client that you created in the list of \u0026ldquo;Applications\u0026rdquo;\nNote that \u0026ldquo;myapp\u0026rdquo; is in the above list of Applications.\nTesting out your User Now make a Direct Grant as described in the Resource Owner Password Credentials. Here is an example:\ncurl --request POST \u0026#39;https://keycloak.harrisonkiang.com/auth/realms/demo/protocol/openid-connect/token\u0026#39; \\ --header \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; \\ --data-urlencode \u0026#39;username=johndoe\u0026#39; \\ --data-urlencode \u0026#39;password=johndoe\u0026#39; \\ --data-urlencode \u0026#39;client_id=myapp\u0026#39; \\ --data-urlencode \u0026#39;client_secret=90a47b27-6de6-43e9-a300-4eb02f18b447\u0026#39; \\ --data-urlencode \u0026#39;grant_type=password\u0026#39; The username and password are that of the user, the client_id is the name of the client, and the client_secret is the value of \u0026ldquo;Secret\u0026rdquo; in the \u0026ldquo;Credentials\u0026rdquo; tab of the client. You should get back a response with an access token, refresh token, etc.\nSecuring your application Setting up the gatekeeper sidecar We\u0026rsquo;re going to use Keycloak Gatekeeper. It will be set up as a sidecar in the same pod containing our application.\nLet\u0026rsquo;s first create an application:\nhelm create app The following files will be created:\napp ├── charts ├── Chart.yaml ├── templates │ ├── deployment.yaml │ ├── _helpers.tpl │ ├── hpa.yaml │ ├── ingress.yaml │ ├── NOTES.txt │ ├── serviceaccount.yaml │ ├── service.yaml │ └── tests │ └── test-connection.yaml └── values.yaml We can get rid of the following in templates/:\n hpa.yaml tests/  cd app/templates/ rm -rf hpa.yaml tests/ We\u0026rsquo;re going to Configure a Pod to Use a ConfigMap to store our Keycloak.\n# app/templates/configmap.yaml data: keycloak-gatekeeper.yaml: |# is the url for retrieve the OpenID configuration - normally the \u0026lt;server\u0026gt;/auth/realm/\u0026lt;realm_name\u0026gt; discovery-url: {{ .Values.keycloak.discoveryUrl }} # the client id for the \u0026#39;client\u0026#39; application client-id: {{ .Values.keycloak.clientId }} # the secret associated to the \u0026#39;client\u0026#39; application client-secret: {{ .Values.keycloak.clientSecret }} # enforces the cookie to be secure\u0026#34;` secure-cookie: false # the interface definition you wish the proxy to listen, all interfaces is specified as \u0026#39;:\u0026lt;port\u0026gt;\u0026#39;, unix sockets as unix://\u0026lt;REL_PATH\u0026gt;|\u0026lt;/ABS PATH\u0026gt; listen: :3000 # whether to enable refresh tokens enable-refresh-tokens: true # the redirection url, essentially the site url, note: /oauth/callback is added at the end redirection-url: http://{{ get $hosts \u0026#34;host\u0026#34;}} # the encryption key used to encode the session state encryption-key: \u0026#34;{{ randAlphaNum 32 }}\u0026#34; # the upstream endpoint which we should proxy request upstream-url: http://127.0.0.1:80 See Configuration options for details on each config. We\u0026rsquo;ll need to set some of the values we use in the above config.\n# app/values.yaml keycloak: clientId: app clientSecret: 90a47b27-6de6-43e9-a300-4eb02f18b447 discoveryUrl: https://keycloak.harrisonkiang.com/auth/realms/demo The client secret is relatively safe to share, as the user will require valid credentials to access the protected resources in your app, which is the whole point of securing your app in the first place.\nI\u0026rsquo;m using a TLS secret (see below):\n# app/values.yaml ingress: tls: - secretName: harrisonkiang-dot-com-wildcard-tls  The above TLS secret is not provided in the code samples at https://github.com/hkiang01/keycloak-demo. You can configure your own TLS secrets or else rely on the Default SSL Certificate created by NGINX Ingress Controller.\n Of course we\u0026rsquo;ll need to use said configmap:\n# app/templates/deployment.yaml containers: - name: gatekeeper image: quay.io/louketo/louketo-proxy:1.0.0 args: - --config=/etc/config/keycloak-gatekeeper.yaml volumeMounts: - name: gatekeeper-config mountPath: /etc/config imagePullPolicy: {{ .Values.image.pullPolicy }} ports: - name: gatekeeper containerPort: 3000 protocol: TCP - name: {{ .Chart.Name }} securityContext: {{- toYaml .Values.securityContext | nindent 12 }} image: \u0026#34;{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}\u0026#34; imagePullPolicy: {{ .Values.image.pullPolicy }} ports: - name: http containerPort: 80 protocol: TCP livenessProbe: httpGet: path: / port: http readinessProbe: httpGet: path: / port: http resources: {{- toYaml .Values.resources | nindent 12 }} volumes: - name: gatekeeper-config configMap: name: {{ include \u0026#34;app.fullname\u0026#34; . }}-gatekeeper Deploy secured app Let\u0026rsquo;s deploy\nhelm -n keycloak upgrade --install app app Now let\u0026rsquo;s make sure everything is ready\nhelm -n keycloak get manifest app | kubectl -n keycloak get -f - NAME SECRETS AGE serviceaccount/app 1 29m NAME DATA AGE configmap/app-gatekeeper 1 29m NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/app ClusterIP 10.152.183.125 \u0026lt;none\u0026gt; 80/TCP 29m NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/app 1/1 1 1 29m NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/app \u0026lt;none\u0026gt; app.harrisonkiang.com 127.0.0.1 80, 443 29m and that the pod is up\nkubectl -n keycloak get pod -l=app.kubernetes.io/instance=app NAME READY STATUS RESTARTS AGE app-78d9484d86-8hvsd 2/2 Running 0 31m 2/2 means we\u0026rsquo;re good to go. Now you should be able to almost log in as normal.\nFixing the audience You\u0026rsquo;ll find that after trying to log in your app via the browser you won\u0026rsquo;t get what you expect. This is due to the fact that you have to manually add your client_id to the audience field aud of the access token per this SO post, the important bit of which is in the snippet below:\n Configure audience in Keycloak\n Add realm or configure existing Add client my-app or use existing Goto to the newly added \u0026ldquo;Client Scopes\u0026rdquo; menu [1]  Add Client scope \u0026lsquo;good-service\u0026rsquo; Within the settings of the \u0026lsquo;good-service\u0026rsquo; goto Mappers tab  Create Protocol Mapper \u0026lsquo;my-app-audience\u0026rsquo;  Name: my-app-audience Choose Mapper type: Audience Included Client Audience: my-app Add to access token: on       Configure client my-app in the \u0026ldquo;Clients\u0026rdquo; menu  Client Scopes tab in my-app settings Add available client scopes \u0026ldquo;good-service\u0026rdquo; to assigned default client scopes     After following the above you should be able to successfully acces your application!\nSome understanding To understand the flow, let\u0026rsquo;s examine how the traffic travels from the outside to the app with and without Keycloak.\ngraph LR outside--ingress subgraph Kubernetes ingress--service service service--app subgraph Pod app end end  Here\u0026rsquo;s what it looks like with Keycloak\ngraph LR outside--ingress subgraph Kubernetes ingress--service service service--gatekeeper subgraph Pod gatekeeper gatekeeper--app end end  All traffic is gated via the gatekeeper, which ensures all requests are secure. If the credentials are invalid or expired, then the user will be redirected to log back in via Keycloak.\nIf we look closer at the service, we\u0026rsquo;ll see that the named targetPort points to the gatekeeper container in the pod:\n# app/templates/service.yaml - port: {{ .Values.service.port }} targetPort: gatekeeper # \u0026lt;--- LOOK HERE protocol: TCP name: http Next steps  Secure secrets in encrypted form using something like Sealed Secrets for Kubernetes Make Postgres highly available by using the postgresql-ha artifact Make your Keycloak instance highly available using Clustering  Worth considering if every client accessing every secured application in your cluster is accessing your Keycloak instance    "},{"uri":"https://hkiang01.github.io/python/testing-abstractions/","title":"Testing Abstractions","tags":[],"description":"","content":" TL;DR Setting the stage The Library Natural Evolution of (Bad) Tests The secret sauce Full example What does this mean?  TL;DR Parametrizing fixtures can enable testing all derived classes of a given base class while keeping tests DRY. Check out The secret sauce.\nSetting the stage You\u0026rsquo;ll eventually get to a point where you decide to start maintaining a Python package to include all of your standard logic used in multiple projects. This has a few advantages:\n Take advantage of existing package management solutions for a smooth upgrade process  poetry, pip, etc.   Reuse: \u0026ldquo;Write once, run anywhere\u0026rdquo;  Easy to sell to your boss, other money people Applies to both implementation and tests   Take advantage of inheritance  i.e., class Base can be implemented by class DerivedA, and class DerivedB    The last bit is quite valuable: Let\u0026rsquo;s say there\u0026rsquo;s a vendor offering that your company\u0026rsquo;s applications use via the class Base abstractoin in your Python package. Said vendor offering can be implemented directly in class DerivedA. However, it\u0026rsquo;s been determined that a separate vendor offering will be a better fit going forward.\nThe switch from the \u0026ldquo;old\u0026rdquo; vendor offering to the \u0026ldquo;new\u0026rdquo; would then look something like this:\n implement the \u0026ldquo;new\u0026rdquo; vendor offering in class DerivedB in a new version of the Python package update the package in the application change the application logic to use the class DerivedB to ultimately use the \u0026ldquo;new\u0026rdquo; vendor offering behind-the-scenes  Great, but what about tests? The promise of \u0026ldquo;Write once, run anywhere\u0026rdquo; isn\u0026rsquo;t as obvious. Luckily, we can take advantage of Parametrizing fixtures so as to keep our tests DRY. Now let\u0026rsquo;s see a more concrete example\nThe Library Let\u0026rsquo;s say our library code looks like this\n# library/module.py class Base: def do_the_thing(self) -\u0026gt; str: raise NotImplementedError class DerivedA(Base): def do_the_thing(self) -\u0026gt; str: return \u0026#34;I did it\u0026#34; class DerivedB(Base): def do_the_thing(self) -\u0026gt; str: return \u0026#34;I did it better\u0026#34; Natural Evolution of (Bad) Tests This is what our tests would look like if we just had them written for DerivedA:\nimport pytest def test_do_the_thing(): base: Base = DerivedA() result = base.do_the_thing() assert \u0026#34;I did it\u0026#34; in result Okay, then naturally we\u0026rsquo;ll just add another test for DerivedB such that our tests look like this:\ndef test_do_the_thing_a(): base: Base = DerivedA() result = base.do_the_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_the_thing_b(): base: Base = DerivedB() result = base.do_the_thing() assert \u0026#34;I did it\u0026#34; in result It\u0026rsquo;s easy to see how this can be a bit repetitive, especially if the base class looks like this:\nclass Base: def do_the_thing(self) -\u0026gt; str: raise NotImplementedError def do_the_other_thing(self) -\u0026gt; str: raise NotImplementedError def do_this_thing(self) -\u0026gt; str: raise NotImplementedError def do_that_thing(self) -\u0026gt; str: raise NotImplementedError class DerivedA(Base): def do_the_thing(self) -\u0026gt; str: return \u0026#34;I did it\u0026#34; def do_the_other_thing(self) -\u0026gt; str: return \u0026#34;I did it\u0026#34; def do_this_thing(self) -\u0026gt; str: return \u0026#34;I did it\u0026#34; def do_that_thing(self) -\u0026gt; str: return \u0026#34;I did it\u0026#34; class DerivedB(Base): def do_the_thing(self) -\u0026gt; str: return \u0026#34;I did it better\u0026#34; def do_the_other_thing(self) -\u0026gt; str: return \u0026#34;I did it better\u0026#34; def do_this_thing(self) -\u0026gt; str: return \u0026#34;I did it better\u0026#34; def do_that_thing(self) -\u0026gt; str: return \u0026#34;I did it better\u0026#34; Then your tests would look like this:\ndef test_do_the_thing_a(): base: Base = DerivedA() result = base.do_the_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_the_thing_b(): base: Base = DerivedB() result = base.do_the_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_the_other_thing_a(): base: Base = DerivedA() result = base.do_the_other_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_the_other_thing_b(): base: Base = DerivedB() result = base.do_the_other_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_this_thing_a(): base: Base = DerivedA() result = base.do_this_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_this_thing_b(): base: Base = DerivedB() result = base.do_this_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_that_thing_a(): base: Base = DerivedA() result = base.do_that_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_that_thing_b(): base: Base = DerivedB() result = base.do_that_thing() assert \u0026#34;I did it\u0026#34; in result This is what you\u0026rsquo;re doing when writing stuff like above.\nStop it. You know you can do better. So do better.\nThe secret sauce Instead, your tests can look like this:\ndef test_do_the_thing(base: Base): result = base.do_the_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_the_other_thing(base: Base): result = base.do_the_other_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_this_thing(base: Base): result = base.do_this_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_that_thing(base: Base): result = base.do_that_thing() assert \u0026#34;I did it\u0026#34; in result Parametrizing fixtures is what makes the above possible:\n@pytest.fixture(params=[cls for cls in Base.__subclasses__()]) def base(request) -\u0026gt; Base: if request.param == DerivedA: return DerivedA() elif request.param == DerivedB: return DerivedB() What is happening, exactly? The docs can say it best:\n The main change is the declaration of params with @pytest.fixture, a list of values for each of which the fixture function will execute and can access a value via request.param. No test function code needs to change.\n Full example import pytest class Base: def do_the_thing(self) -\u0026gt; str: raise NotImplementedError def do_the_other_thing(self) -\u0026gt; str: raise NotImplementedError def do_this_thing(self) -\u0026gt; str: raise NotImplementedError def do_that_thing(self) -\u0026gt; str: raise NotImplementedError class DerivedA(Base): def do_the_thing(self) -\u0026gt; str: return \u0026#34;I did it\u0026#34; def do_the_other_thing(self) -\u0026gt; str: return \u0026#34;I did it\u0026#34; def do_this_thing(self) -\u0026gt; str: return \u0026#34;I did it\u0026#34; def do_that_thing(self) -\u0026gt; str: return \u0026#34;I did it\u0026#34; class DerivedB(Base): def do_the_thing(self) -\u0026gt; str: return \u0026#34;I did it better\u0026#34; def do_the_other_thing(self) -\u0026gt; str: return \u0026#34;I did it better\u0026#34; def do_this_thing(self) -\u0026gt; str: return \u0026#34;I did it better\u0026#34; def do_that_thing(self) -\u0026gt; str: return \u0026#34;I did it better\u0026#34; @pytest.fixture(params=[cls for cls in Base.__subclasses__()]) def base(request) -\u0026gt; Base: if request.param == DerivedA: return DerivedA() elif request.param == DerivedB: return DerivedB() def test_do_the_thing(base: Base): result = base.do_the_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_the_other_thing(base: Base): result = base.do_the_other_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_this_thing(base: Base): result = base.do_this_thing() assert \u0026#34;I did it\u0026#34; in result def test_do_that_thing(base: Base): result = base.do_that_thing() assert \u0026#34;I did it\u0026#34; in result What does this mean? If we implement class Base in a class DerivedC, we\u0026rsquo;ll get the tests for free!\nNote that params=[cls for cls in Base.__subclasses__()] makes this possible in the base() fixture.\nThis is pretty based lol\n"},{"uri":"https://hkiang01.github.io/kubernetes/wildcard-certs/","title":"Wildcard certs","tags":[],"description":"","content":"This is NOT representative of what I do at work (mostly for my home hobby cluster).\nOnce you have NGINX set up, each of your services can sit behind an Ingress with a host resembling something close to myservice.mydomain.com. That\u0026rsquo;s great and all, but you\u0026rsquo;ll find that your connections aren\u0026rsquo;t secured until you configure TLS.\nSome understanding You\u0026rsquo;ll need to pass a DNS-01 challenge. The challenge itself is run by servers from a certificate authority (CA) such as Let\u0026rsquo;s Encrypt. Those servers expect your web server to be reachable from whatever IP address your domain points to.\nClusters with a public IP It\u0026rsquo;s fairly straightforward to secure your services via cert-manager as the Let\u0026rsquo;s Encrypt servers will be able to reach your node clusters (which play the role of your web server).\nClusters without a public IP Solutions like cert-manager won\u0026rsquo;t work out of the box here. Essentially you\u0026rsquo;ll need to stand up a web service apart from your cluster that has a static IP for the sole purpose of getting the pem certs requried to generate your TLS Secrets. AWS, Google Cloud, etc., are able to provide here.\nNote: the following instructions are tested on a server running Ubuntu 20.04:\n  Set up a server with a publicly accessible static IP address either in the cloud or some other hosting provider you trust.\n  Create an A record pointing to its static IP. Below is an example:\n  Replace the IP address Value with your server\u0026rsquo;s static IP.\nInstall the following in the same server:   certbot  used to get tls cert from Let\u0026rsquo;s Encrypt   nginx  used as the installer plugin when combining plugins   kubectl  used to locally render the secret to copy over to our private cluster    In your publicly available server, create an index.html file that will display something.  # server with publicly available static ip cd /var/www sudo mkdir tutorial cd tutorial sudo \u0026#34;${EDITOR:-vi}\u0026#34; index.html \u0026lt;!-- index.html --\u0026gt; \u0026lt;!-- This is what the nginx server will return --\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, Nginx!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, Nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;We have just configured our Nginx web server on Ubuntu Server!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; In your publicly available server, configure NGINX as shown below:  # server with publicly available static ip cd /etc/nginx/sites-enabled sudo \u0026#34;${EDITOR:-vi}\u0026#34; tutorial server { listen 80; listen [::]:80; server_name *.mydomain.com; root /var/www/tutorial; index index.html; location / { try_files $uri $uri/ =404; } } The above config is just a simple nginx server that listens on a wildcard path returning a simple response.\nIn your publicly available server, use certbot with the manual plugin as the authenticator and the nginx plugin as the installer to grant your wildcard cert:  # server with publicly available static ip certbot run -a manual -i nginx -d *.mydomain.com When prompted, create a TXT record in your DNS like below:  Be careful to not put your domain in as the Host in the TXT record\n Wait until your TXT record propogates through the Internet\u0026rsquo;s DNS servers. You can use a site like https://mxtoolbox.com/SuperTool.aspx\n  When you successfully acquire your wildcard cert, create the Kubernetes TLS secret in your publicly available server, like below:\n  # server with publicly available static ip # only sudo has access to the directory we need to get to sudo -s cd /etc/letsencrypt/live/mydomain.com/ # create the TLS secret kubectl create secret tls mydomain-dot-com-wildcard-tls --cert fullchain.pem --key privkey.pem --dry-run -o yaml \u0026gt; mydomain-com-wildcard-tls.yaml # move the yaml file to someplace you\u0026#39;ll be able to scp from on your local machine, likely your user\u0026#39;s home directory mv mydomain-com-wildcard-tls.yaml /home/myuser/ Move your secret to your local machine  # local machine scp my_user@my_server_ip:/home/myuser/mydomain-com-wildcard-tls.yaml . You likely want to change the namespace of your secret so that when you apply it it\u0026rsquo;s available for your service to reference by name. Change metadata.namespace accordingly, for example:  # mydomain-com-wildcard-tls.yaml ... metadata: namespace: my-namespace ... Apply the secret  kubectl apply mydomain-com-wildcard-tls.yaml  You can now guard your service using your newly created cert. Here\u0026rsquo;s an example of TLS termination using ingress-nginx\n  Oh yeah, you probably want to delete your NGINX web server instance so as not keeping your TLS secrets \u0026ldquo;exposed\u0026rdquo;\u0026hellip;.\n  "},{"uri":"https://hkiang01.github.io/kubernetes/","title":"Kubernetes","tags":[],"description":"","content":"Chapter 2 Kubernetes A few things I learned about Kubernetes\n Keycloak  Secure your applications with an open source Identity Managment solution   Wildcard Certs  How to secure your cluster\u0026rsquo;s services using TLS (manual)    "},{"uri":"https://hkiang01.github.io/python/","title":"Python","tags":[],"description":"","content":"Chapter 3 Python A few things I learned while developing in Python\n Testing Abstractions Efficiently  Paramterize your fixtures to reduce the number of tests you have to write    "},{"uri":"https://hkiang01.github.io/","title":"Some reading material","tags":[],"description":"","content":"Blog My name is Harrison Kiang and this is my blog. I work with Kubernetes and Machine Learning.\nI have been meaning to make a blog for awhile now. I finally found a way to do it without it being too much of a drag. This was built with Hugo Learn Theme. It looks nice and allows me to just focus on content creation and automates away a lot of the overhead. I can write in Markdown, create Mermaid diagrams, etc.\nArticles Philosophy  A few things I believe are true  Kubernetes  Keycloak  Secure your applications with an open source Identity Managment solution   Wildcard Certs  How to secure your cluster\u0026rsquo;s services using TLS (manual)    Python  Testing Abstractions Efficiently \u0026lt;\u0026ndash; Newest article!  Paramterize your fixtures to reduce the number of tests you have to write    "},{"uri":"https://hkiang01.github.io/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://hkiang01.github.io/tags/","title":"Tags","tags":[],"description":"","content":""}]